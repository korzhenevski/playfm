<html>
<body>
<script language="JavaScript" type="text/javascript">
Comet_Loader = {
	// Maximum bounce count.
	JS_MAX_BOUNCES: 5,
	
	// Reconnect delay.
	JS_WAIT_RECONNECT_DELAY: 0.3,
	
	// Realplexor WAIT url parts.
	JS_WAIT_URI: "{{ url_for('onair') }}",
	
	// Realplexor normal WAIT timeout (seconds).
	JS_WAIT_TIMEOUT: 25,

	// It debug mode turned on?
	JS_DEBUG: true,
	
	// Count of sequential bounces.
	_bounceCount: 0,
	
	// Previous request time.
	_prevReqTime: null,
	
	// Previously used xmlhttp.
	_lastXmlhttp: null,
	
	// Callback will be called on data ready.
    callback: {},
	
	// Work-around for stupid IE. Unfortunately IE cannot catch exceptions
	// thrown from a callback created in a different frame, so we run such
	// callbacks wrapped by _callAndReturnException function. This
	// function is passed from the parent frame.
	_callAndReturnException: null,
	
	// Return the parent's document.
	_doc: function() {
		return parent.document;
	},
	
	// Create a new XMLHttpRequest object.
	_getXmlHttp: function() {
		var xmlhttp;
		if (typeof XMLHttpRequest != 'undefined') {
			xmlhttp = new XMLHttpRequest();
		}
		if (!xmlhttp) try {
			xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
		} catch (e) {
		}
		if (!xmlhttp) try {
			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
		} catch (e) {
		}
		return xmlhttp;
	},
	
	// Log a debug message.
	_log: function(msg, func) {
		if (!this.JS_DEBUG) return;
		if (window.console) {
			if (!func) func = "log";
			var multiline = false;
			if ((""+msg).match(/^([^\r\n]+)\r?\n([\s\S]*)$/)) {
				var first = RegExp.$1, second = RegExp.$2;
				if (console.groupCollapsed) {
					console.groupCollapsed(first);
					console[func](second + "\n");
					console.groupEnd();
				} else {
					console.info(first);
					console[func](second + "\n");
				}
			} else {
				console[func](msg);
			}
		}
	},

	// Log an error message.
	_error: function(prefix, msg) {
		this._log(prefix, "error");
		this._log(msg);
	},
	
	// Process the response data.
	_processResponseText: function(text) {
		// Safary bug: responseText sometimes contain headers+body, not only body!
		// So cat before the first "[".
		text = text.replace(/^[\s\S]*?(?=\[)/g, '');
		this._log("Received response:\n" + text);
		// Parse.
        if (! (text && text[0] == '{') ) {
            throw "Response is not a complete JSON";
        }
        var data;
        eval("data = " + text);
        var e = this._callAndReturnException(this.callback.callback, [data]);
        if (e) {
            this._error("Error executing callback " + this.callback.params + ": " + e, "Data:\n" + data);
        }
    },
    	
    // Called on response arrival.
    _onresponse: function(text) {
		var nextQueryDelay = Math.round(this.JS_WAIT_RECONNECT_DELAY * 1000);
			
		// Work-around to handle page unload. In case of this handler is executed after
		// the page is partly unloaded, do nothing, just return.
		try {
			if (!this._doc().body) return;
		} catch (ex) {
			return;
		}
			
		// Run the query.
		var errors = 0;
		try {
			// Empty response typically means that there is no error, but
			// server WAIT timeout expired and we need to reconnect.
			// But we exit via exception to check: is it a bounce or not.
			if (text.match(/^\s*$/)) {
				text = "";
				throw "Empty response";
			}
			this._processResponseText(text);
			this._bounceCount = 0;
		} catch (e) {
			var t = new Date().getTime();
			if (t - this._prevReqTime < this.JS_WAIT_TIMEOUT / 2 * 1000) {
				// This is an unexpected disconnect (bounce).
				this._bounceCount++;
				this._log("Bounce detected (bounceCount = " + this._bounceCount + ")");
			} else {
				this._log("Disconnect detected");
			}
			if (text != "") {
				this._error(e.message? e.message : e, "Response:\n" + text);
			}
			this._prevReqTime = t;
		}
			
		// Calculate next query delay.
		if (this._bounceCount > this.JS_MAX_BOUNCES) {
			// Progressive delay.
			var progressive = this._bounceCount - this.JS_MAX_BOUNCES + 2;
			nextQueryDelay = 1000 + 500 * progressive * progressive;
			if (nextQueryDelay > 60000) nextQueryDelay = 60000;
		}
			
		// Schedule next query, but only if there was no other request
		// performed (e.g. via execute() call) within the callback.
		if (!this._lastXmlhttp) {
			this._log("Next query in " + nextQueryDelay + " ms");
			var th = this;
			setTimeout(function() { th._loopFunc() }, nextQueryDelay);
		}
    },

    	
	// Loop function.
	_loopFunc: function() {
        if (! this.callback) {
            return false;
        }
        var params = this.callback.params + '&r=' + (new Date().getTime());
        if (this.callback._cursor) {
            params += '&cursor=' + this.callback._cursor
        }
        var url = this.JS_WAIT_URI + '?' + params;
		var xmlhttp = this._getXmlHttp();
		if (!xmlhttp) {
			this._error("No XMLHttpRequest found!");
			return;
		}

		var th = this;
		xmlhttp.open('GET', url, true);
        xmlhttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        xmlhttp.onreadystatechange = function() {
			if (xmlhttp.readyState != 4) return;
			if (!th._lastXmlhttp) return; // abort() called
			th._lastXmlhttp = null;
            if (xmlhttp.status == 200) {
			    th._onresponse("" + xmlhttp.responseText);
            } else {
                th._onresponse('');
            }
			th = null;
		}
		xmlhttp.send(null);
		this._prevReqTime = new Date().getTime();
		this._lastXmlhttp = xmlhttp;
        this.callback._cursor = this.callback._cursor ? this.callback._cursor + 1 : 1;
	},

	// Run the polling process.
	// Second parameter must accept a function which will be called to
	// call parent's callbacks (it is needed for IE, to not to loose
	// exceptions thrown from a different frame).
	execute: function(callback, callAndReturnException) {
		var th = this;
		window.onunload = function() { 
			// This is for IE7: it does not abort the connection on unload
			// and reaches the connection limit.
			try { 
				if (th._lastXmlhttp) {
					th._lastXmlhttp.onreadystatechange = function(){};
					th._lastXmlhttp.abort();
					th._lastXmlhttp = null;
				}
			} catch (e) {}
		}
		if (this._lastXmlhttp) {
			var xhr = this._lastXmlhttp;
			this._lastXmlhttp = null;
			xhr.onreadystatechange = function(){};
			xhr.abort();  // abort() does not make bounce if this._lastXmlhttp is null
		}
		this.callback = callback;
        if (!this.callback) {
            // if unsubscribed
            return;
        }
		this._callAndReturnException = callAndReturnException;
		this._loopFunc();
	},
	
	// Prepare Realplexor to execution.
	prepare: function() {
		if (!document.location.search.match(/HOST=([^&]+)/)) {
			this._error("IFRAME src attribute must contain HOST=... specifier - parent's host name");
			return;
		}
		document.domain = RegExp.$1;
	}
}
Comet_Loader.prepare();
</script>
</body>
</html>	
